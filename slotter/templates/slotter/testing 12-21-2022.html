<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	{% load static %}
	<link rel="stylesheet" type="text/css" href="{% static 'slotter/style.css' %}">
	<link href="https://fonts.googleapis.com/css2?family=Cabin&family=Inconsolata:wdth,wght@95,300;100,400;100,800" rel="stylesheet">
	<title>Testing</title>
</head>
<body>
<div id="header">
	<svg id="logo" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 284.82 83.04" width="150">
  		<defs>
	    <style>
	      .cls-1 {
	        fill: #fc0;
	      }
	    </style>
	  	</defs>
	  <path d="M90.21,14.94c15.03,0,25.44,10.9,25.44,24.26s-10.37,24.21-25.53,24.21-25.27-10.85-25.27-24.21,10.37-24.26,25.36-24.26Zm.09,36.83c6.64,0,11.82-4.97,11.82-12.61s-5.23-12.52-11.87-12.52-11.82,5.01-11.82,12.52,5.32,12.61,11.87,12.61Z"/>
	  <path d="M3.78,47.64c6.33,3.65,10.81,4.66,14.68,4.66,5.1,0,7.82-1.45,7.82-3.87-.04-2.94-3.52-3.3-11.34-5.01-5.36-1.1-14.06-3.16-14.06-13.58,0-9.32,6.64-14.94,19.6-14.94,7.12,0,13.23,1.27,19.2,4.13l-3.52,10.59c-4.75-1.93-10.15-3.69-15.29-3.69-4.53,0-6.2,1.85-6.15,3.78,0,2.24,2.46,3.12,8.61,3.96,9.62,1.71,17.89,3.78,17.89,13.84s-9.14,15.95-21.31,15.95c-7.65,0-13.01-.88-19.91-4.57l3.78-11.25Z"/>
	  <path d="M130.97,3.78l9.76-.09v12.66h13.23v11.65h-13.23v16c0,5.67,2.81,7.12,6.46,7.12h7.6l-.09,11.12h-8.83c-10.24,0-18.68-2.77-18.68-18.11V27.99h-7.25v-10.37l6.9-2.64,4.13-11.21Z"/>
	  <path d="M169.73,3.78l9.76-.09v12.66h13.23v11.65h-13.23v16c0,5.67,2.81,7.12,6.46,7.12h7.6l-.09,11.12h-8.83c-10.24,0-18.68-2.77-18.68-18.11V27.99h-7.25v-10.37l6.9-2.64,4.13-11.21Z"/>
	  <path d="M213.93,44.82c1.98,4.39,6.24,7.08,11.03,7.08,5.62,0,7.87-1.45,10.46-3.47l7.38,8.09c-3.21,3.03-9.54,6.94-17.97,6.94-14.77,0-25.14-11.07-25.14-24.3s10.33-24.3,25.18-24.3c12.96,0,21.27,6.55,21.27,16,0,7.51-3.87,13.97-16.48,13.97h-15.73Zm-.18-10.99h13.71c3.56,0,5.76-1.32,5.76-3.43,0-1.98-2.55-4.35-8-4.35-5.01,0-9.49,3.08-11.47,7.78Z"/>
	  <path d="M284.82,28.17l-5.71,.04c-7.47,0-11.91,4.22-11.91,12.52v21.18h-13.54V16.35h10.9l1.05,4.31c2.9-2.42,7.12-4.31,12.74-4.31h6.46v11.82Z"/>
	  <path d="M55.83,39.16c0-6.59,2.54-12.6,6.93-16.98V0h-13.58V45.53c0,12.61,3.21,16.44,16.96,16.44h2.86v-1.36c-8.09-4.05-13.17-12.14-13.17-21.45Z"/>
	  <rect class="cls-1" y="70.57" width="68.99" height="12.47" rx="3.6" ry="3.6"/>
	</svg>
	<div class="menu_item"><span id="active_task"><a href="/slotter/create/">create</a></span></div>
	<div class="menu_item"><a href="/slotter/start/">schedule</a></div>
	</div>
	<div id="number_nav">
		<div class="num_nav_item"><a href="/slotter/create/">1. create new section //</a> <a href="/slotter/edit_section/"><span id="active_step">edit section</span></a></div>
		<hr class="nav_connector">
		<div class="num_nav_item"><span class="step_tbd"><a href="/slotter/import/">2. import data</a></span></div>
	</div>
	<div id="main">
		<h1 id="results_header"><span id="header_text1"></span><span id="n_assgs" class="red_highlight"></span><span id="header_text2"></span></h1>
		<svg id="slotting_loader" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 281.27 120.21">
		  <defs>
		    <style>
		      .cls-0 {
		        fill: #f0532f;
		      }

		      .cls-2 {
		        fill: #ffcc04;
		      }

		      .cls-3 {
		        fill: #231f20;
		      }
		    </style>
		  </defs>
		  <rect id="loader_square" class="cls-0" x="60.11" width="33.44" height="33.44"/>
		   <path id="loader_circle" class="cls-0" d="M76.76,0c-11.95,0-20.25,8.75-20.25,19.41s8.33,19.37,20.21,19.37,20.43-8.65,20.43-19.37S88.82,0,76.76,0Z"/>
		  <path id="loader_s" class="cls-3" d="M3.02,68.49c5.06,2.92,8.65,3.73,11.74,3.73,4.08,0,6.26-1.16,6.26-3.09-.04-2.36-2.81-2.64-9.07-4.01-4.29-.88-11.25-2.53-11.25-10.86,0-7.45,5.31-11.95,15.68-11.95,5.7,0,10.58,1.02,15.36,3.3l-2.81,8.47c-3.8-1.55-8.12-2.95-12.23-2.95-3.62,0-4.96,1.48-4.92,3.02,0,1.79,1.97,2.5,6.89,3.16,7.7,1.37,14.31,3.02,14.31,11.07s-7.31,12.76-17.05,12.76c-6.12,0-10.41-.7-15.93-3.66l3.02-9Z"/>
		  <g id="loader_back_letters">
		  <path id="loader_first_t" class="cls-3" d="M111.63,33.4l7.8-.07v10.12h10.58v9.32h-10.58v12.8c0,4.54,2.25,5.7,5.17,5.7h6.08l-.07,8.89h-7.07c-8.19,0-14.94-2.21-14.94-14.48v-12.9h-5.8v-8.3l5.52-2.11,3.3-8.96Z"/>
		  <path id="loader_second_t" class="cls-3" d="M143.13,33.4l7.8-.07v10.12h10.58v9.32h-10.58v12.8c0,4.54,2.25,5.7,5.17,5.7h6.08l-.07,8.89h-7.07c-8.19,0-14.94-2.21-14.94-14.48v-12.9h-5.8v-8.3l5.52-2.11,3.3-8.96Z"/>
		  <path id="loader_i" class="cls-3" d="M175.44,27.88c3.94,0,6.5,2.64,6.5,5.77s-2.57,5.73-6.54,5.73-6.47-2.64-6.47-5.73,2.57-5.77,6.5-5.77Zm-5.55,15.57h10.93v36.46h-10.93V43.46Z"/>
		  <path id="loader_n" class="cls-3" d="M228.7,79.92h-10.93v-19.3c0-6.75-2.95-8.96-7.17-8.96-5.38,0-8.72,4.22-8.72,9.95v18.32h-10.86V43.46h8.75l.67,2.78c3.02-2.14,7.38-3.94,11.74-3.94,11.6,0,16.52,6.86,16.52,18.07v19.55Z"/>
		  <path id="loader_g" class="cls-3" d="M276.27,41.03v7.49h-3.09c-1.2,0-2.36,.42-3.34,.95,.95,1.79,1.48,3.76,1.48,5.84,0,7.63-6.54,13.61-17.23,13.61-2.53,0-4.78-.32-6.82-.95-.49,.81-.74,1.72-.7,2.46,0,2.04,2.5,2.21,4.22,2.21h6.68c11.6,0,16.28,5.27,16.28,11.11,0,8.86-8.79,13.46-19.93,13.46-10.2,0-19.3-3.55-19.3-11.64,0-2.46,1.83-5.27,4.22-7.49-1.69-1.48-2.57-3.52-2.57-5.73,0-3.06,1.79-6.01,4.18-8.54-2.18-2.32-3.34-5.27-3.34-8.51,0-7.52,6.47-13.85,17.12-13.85,3.8,0,7.07,.81,9.7,2.18,1.69-1.3,4.01-2.6,7.03-2.6h5.41Zm-30.38,39.41c-.21,0-.39-.04-.6-.04-.84,1.09-1.48,2.32-1.48,3.76,0,3.52,4.32,4.57,9.84,4.57s9.18-1.93,9.18-4.61-2.78-3.73-6.79-3.73l-10.16,.04Zm8.23-19.3c3.9,0,6.68-2.39,6.68-5.94s-2.78-5.87-6.68-5.87-6.54,2.39-6.54,5.87,2.78,5.94,6.54,5.94Z"/>
			</g>
		  <path id="loader_l" class="cls-3" d="M45.35,61.74c0-5.26,2.03-10.06,5.52-13.57V30.38h-10.86v36.42c0,10.09,2.57,13.15,13.57,13.15h2.29v-1.06c-6.47-3.24-10.51-9.7-10.51-17.15Z"/>
		  <rect id="loader_underline" class="cls-2" y="85.86" width="56.33" height="10.18" rx="3.6" ry="3.6"/>
		  <polygon id="loader_hexagon" class="cls-0" points="86.99 39.05 66.67 39.05 56.51 21.45 66.67 3.85 86.99 3.85 97.16 21.45 86.99 39.05"/>
		</svg>

		<button id="test_request" type="button">Test request</button>
		<div class="student_assg_form_box" id="refining_forms_div">
			<form method="POST" id="refining_stage1">
				<legend>Do you want to refine these options further?</legend>
				{% csrf_token %}
				{% for field in refine_results_form %}
				<p class="legend_like">{{ field.label_tag }}</p>
				{{field}}
				{% endfor %}
				<br>
			</form>
			<form method="POST" id="refining_stage2">
			{% csrf_token %}
			<div id="pronoun_option">
				<hr class="form_spacer">
				<p class="legend_like">{{refine_results_form2.balance_by_pronouns.label_tag}}</p>
				<div id="pronoun_errors" class="error_box">
				</div>
				<p>{{refine_results_form2.balance_by_pronouns}}</p>
			</div>
			<div id="group_or_avoid_option">
				<hr class="form_spacer">
				<table class="group_or_avoid">
				<tr>
					<td>
						<p class="legend_like">{{refine_results_form2.group_or_avoid.label_tag}}</p>	
					</td>
					<td>
						<p class="legend_like">{{refine_results_form2.students_selected.label_tag}}</p>
					</td>
				</tr>
				<tr>
					<td colspan="2">
						<div id="group_avoid_errors" class="error_box">
						</div>
					</td>
				</tr>
				<tr>
					<td>
						<p class="form_field">{{refine_results_form2.group_or_avoid}}</p>
					</td>
					<td>
						<p class="form_field">{{refine_results_form2.students_selected}}</p>
					</td>
				</tr>
				</table>
			</div>
			<div id="handpick_option">
				<hr class="form_spacer">
				<p class="legend_like">{{refine_results_form2.timeslots_to_handpick.label_tag}}</p>
				<div id="handpick_timeslot_errors" class="error_box">
				</div>
				<p>{{refine_results_form2.timeslots_to_handpick}}</p>
			</div>
			</form>
			<div id="handpick_students_div">
			<hr class="form_spacer">
			<form method="POST">
			{% csrf_token %}
			<p class="legend_like">Handpick students:</p>
				<div id="handpick_student_errors" class="error_box">
				</div>
			<table class="group_or_avoid">
			<tr>
				{% for field in refine_results_form3 %}
				{% if field.is_hidden %}
				{{field}}
				{% else %}
				<td valign="top" id="td_{{field.html_name}}"><strong>{{field.label_tag}}</strong>
				<p>
				{{field}}
				</p>
				</td>
				{% endif %}
				{% endfor %}
			</tr>
			</table>
			</form>
			</div>
			<div id="refining_button_div">
				<br>
				<button type="button" id="refine_button">Refine</button>
			</div>
		</div>
	</div>
	<script>
		let xhr;
		var startTime, endTime;
		var mainDiv = document.getElementById("main");
		var resultsHeader = document.getElementById("results_header")
		var varHeaderText1 = document.getElementById("header_text1")
		var nPossibilities = document.getElementById("n_assgs")
		var varHeaderText2 = document.getElementById("header_text2")
		var testButton = document.getElementById("test_request");
		var loader = document.getElementById("slotting_loader");
		var refiningDiv = document.getElementById("refining_forms_div")
		var refiningForm1 = document.getElementById("refining_stage1");
		var pronounsCheck = document.getElementById("id_refine_options_0");
		var groupOrAvoidCheck = document.getElementById("id_refine_options_1");
		var handpickCheck = document.getElementById("id_refine_options_2");
		var refiningForm2 = document.getElementById("refining_stage2");
		var pronounDiv = document.getElementById("pronoun_option");
		var groupOrAvoidDiv = document.getElementById("group_or_avoid_option");
		var handpickTimeslotsDiv = document.getElementById("handpick_option");
		var handpickStudentsDiv = document.getElementById("handpick_students_div");
		var refineButtonDiv = document.getElementById("refining_button_div");
		const refineButton = document.getElementById("refine_button");
		testButton.addEventListener("click", buttonHandler);
		loader.style.display = "none";
		refiningDiv.style.display = "none";
		pronounDiv.style.display = "none";
		groupOrAvoidDiv.style.display = "none";
		handpickTimeslotsDiv.style.display = "none";
		refineButtonDiv.style.display = "none";
		const nPronounChoices = {{n_pronoun_choices|escapejs}};
		const nStudents = {{student_total|escapejs}};
		const nTimeslots = {{n_timeslots|escapejs}};
		const checkboxLookup = JSON.parse("{{checkbox_ns|escapejs}}");
		const cnetLookup = JSON.parse("{{students_cnet_lookup|escapejs}}");

		hideHandpickStudents()

		var timeslotLookup = JSON.parse("{{json_selected_timeslots|escapejs}}")
		var studentLookup = JSON.parse("{{json_students|escapejs}}")

		function buttonHandler() {
			xhr = new XMLHttpRequest();
			startTime = performance.now()
			xhr.onreadystatechange = alertContents;
			xhr.open("GET", "/slotter/assignment_churn/", true);
			xhr.send();
		}

		function randomishNumber(max) {
			return Math.floor(Math.random() * max)
		}

		function alertContents(){
			if (xhr.readyState === XMLHttpRequest.DONE) {
				endTime = performance.now()
				var loadingDuration = (endTime - startTime) / 1000;
				console.log(loadingDuration);
				// turns off loading animation
				loader.style.display = "none";
				// json data parsing
				const obj = xhr.responseText;
				const jsonObj = JSON.parse(obj);
				const possNumCombos = Object.keys(jsonObj).length;
				// if # of possible combos is huge, then randomly sample 10
				if (possNumCombos > 16) {
					var possibleCombos = []
					for (let i = 0; i<10; i++) {
						let k = randomishNumber(possNumCombos);
						if (!possibleCombos.includes(k) && k !==0) {
							possibleCombos.push(k)
						}
					}
				// if the # of possible combos is 15 or fewer, list all
				} else {
					var possibleCombos = Object.keys(jsonObj)
				}
				console.log(possNumCombos)
				buildHeader(possNumCombos)
				if (possNumCombos > 15) {
					refiningDiv.style.display = "block";
					togglePronounForm();
					toggleGroupAvoidForm();
					toggleHandpickTimeslotsForm();
					toggleRefineButton();
					pronounValidation();
					groupAvoidValidation();
					handpickTimeslotsValidation();
					handpickStudentsValidation();
					refineButtonHandler();
				}
				buildTables(jsonObj, possibleCombos)
			// xml httprequest not done yet, display loading animation
			} else {
				loader.style.display = "block";
			}
		}

		function buildHeader(n) {
			const zeroHeaderText1 = "Sorry, there are ";
			const zeroHeaderText2 = " possible assignments for this combination of times.";
			const oneHeaderText1 = "Hooray! There is ";
			const oneHeaderText2 = " possible assignment:";
			const fifteenFewerHeaderText1 = "Hooray! There are ";
			const fifteenFewerHeaderText2 = " possible assignments:";
			const fifteenPlusHeaderText1 = "Wow, there are ";
			const fifteenPlusHeaderText2 = " possible assignments! Scroll down for 10 randomly selected options...";
			let headerText1;
			let headerText2;
			if (n == 0) {
				headerText1 = zeroHeaderText1;
				headerText2 = zeroHeaderText2;
			} else if (n == 1) {
				headerText1 = oneHeaderText1;
				headerText2 = oneHeaderText2;
			} else if (n < 16) {
				headerText1 = fifteenFewerHeaderText1;
				headerText2 = fifteenFewerHeaderText2;
			} else if (n > 15) {
				headerText1 = fifteenPlusHeaderText1;
				headerText2 = fifteenPlusHeaderText2;
			}
			resultsHeader.style.display = "block";
			varHeaderText1.innerHTML += headerText1;
			nPossibilities.innerHTML+= n;
			varHeaderText2.innerHTML += headerText2;
		}

		function buildTables(data, combos) {
			let i = 1
			var r, c;
			for (let k of combos) {
				let comboTable = document.createElement('table')
				comboTable.classList.add("student_assgs")
				let comboContent = data[k]
				r = comboTable.insertRow()
				c = r.insertCell(0)
				c.colSpan = 3
				c.innerHTML += i;
				let hr = document.createElement('hr');
				hr.classList.add("assg_spacer")
				c.appendChild(hr)
				i = i + 1
				for (let t in comboContent) {
					let timeslot = timeslotLookup[t]["weekday"] + ", " + timeslotLookup[t]["start_time"]
					r = comboTable.insertRow()
					c = r.insertCell(0)
					c = r.insertCell(1)
					c.innerHTML += timeslot;
					c = r.insertCell(2)
					let studentData = comboContent[t];
					let studentList = []
					for (let student of studentData) {
						studentList.push(studentLookup[student]["first_name"] + " " + studentLookup[student]["last_name"]);
					};
					let last = studentList.length - 1
					for (let student of studentList) {
						if (studentList.indexOf(student) !== last) {
							c.innerHTML += student + ", "
						} else {
							c.innerHTML += student
						}
					}
				}
				mainDiv.appendChild(comboTable);
			}
		}

		function togglePronounForm() {
			pronounsCheck.addEventListener("change", function() {
				if (pronounsCheck.checked == true) {
					pronounDiv.style.display = "block";
				} else {
					pronounDiv.style.display = "none";
				}	
			})
		}

		function toggleGroupAvoidForm() {
			groupOrAvoidCheck.addEventListener("change", function() {
				if (groupOrAvoidCheck.checked == true) {
					groupOrAvoidDiv.style.display = "block";
				} else {
					groupOrAvoidDiv.style.display = "none";
				}
			})
		}

		function toggleHandpickTimeslotsForm() {
			handpickCheck.addEventListener("change", function() {
				if (handpickCheck.checked == true) {
					handpickTimeslotsDiv.style.display = "block";
				} else {
					handpickTimeslotsDiv.style.display = "none";
					hideHandpickStudents();
				}
			})
		}

		function toggleRefineButton() {
			let formElements = [pronounsCheck, groupOrAvoidCheck, handpickCheck]
			// tracks whether any of the initial refining options have been checked
			let checks = 0
			// tracks whether any timeslots for handpicking have been checked
			let timeslotChecks = 0
			for (let elem of formElements) {
				elem.addEventListener("change", function() {
					if (elem.checked == true) {
						checks += 1;
					} else {
						checks -= 1;
					}
					// refine button shows up if either the pronoun or group/keep apart option is selected
					if (checks > 0 && handpickCheck.checked == false) {
						refineButtonDiv.style.display = "block";
					// refine button only shows up when at least one timeslot option has been selected
					} else if (handpickCheck.checked == true && timeslotChecks == 0) {
						refineButtonDiv.style.display = "none";
					// if all initial refining options are deselcted, then the refining buttoon disappears
					} else if (checks == 0) {
						refineButtonDiv.style.display = "none";
					}
					// if handpick option is deselected, then tracking of timeslots for handpicking is reset
					if (handpickCheck.checked == false) {
						timeslotChecks = 0;
					}
					console.log(checks)
				})
			}
			for (let i = 0; i < nTimeslots; i++) {
				let checkboxID = "id_timeslots_to_handpick_" + i
				let checkbox = document.getElementById(checkboxID)
				checkbox.addEventListener("change", function() {
					console.log(checkbox.checked)
					// if any timeslot for handpicking is checked, then the refining button shows up
					if (checkbox.checked == true) {
						timeslotChecks += 1
						refineButtonDiv.style.display = "block";
					} else {
						timeslotChecks -= 1
					}
					// if all of the timeslots for handpicking are deselected, then the refining button disappears
					if (timeslotChecks == 0) {
						refineButtonDiv.style.display = "none";
					}
					console.log('timelot checks', timeslotChecks)
				})
			}
		}

		function pronounValidation() {
			let errorBox = document.getElementById("pronoun_errors");
			errorBox.style.display = "none";
			let checks = 0
			for (let i = 0; i < nPronounChoices; i++) {
				let checkboxID = "id_balance_by_pronouns_" + i;
				let checkbox = document.getElementById(checkboxID);
				checkbox.addEventListener("change", function() {
					if (checkbox.checked == true) {
						checks += 1
					}
					else {
						checks -= 1
					}
					console.log(checks)
					if (checks == nPronounChoices) {
						pronounErrorMessage(errorBox);
					} else {
						let errorMessage = document.getElementById("all_pronouns_error");
						if (errorMessage !== null) {
							errorMessage.remove()
						}
						errorBox.style.display = "none";
					}
				})
			}
			pronounsCheck.addEventListener("change", function() {
				if (pronounsCheck.checked == false) {
					uncheck("id_balance_by_pronouns_", nPronounChoices);
					checks = 0;
					let errorMessage = document.getElementById("all_pronouns_error");
					if (errorMessage !== null) {
						errorMessage.remove()
					}
					errorBox.style.display = "none";
				}
			})
		}

		function groupAvoidValidation() {
			let errorBox = document.getElementById("group_avoid_errors");
			errorBox.style.display = "none";
			let checks = 0
			let maxSelection = {{max_n_students_group_avoid|escapejs}}
			for (let i = 0; i < nStudents; i++) {
				let checkboxID = "id_students_selected_" + i;
				let checkbox = document.getElementById(checkboxID);
				checkbox.addEventListener("change", function() {
					if (checkbox.checked == true) {
						checks += 1
					} else {
						checks -= 1
					}
					if (checks > maxSelection) {
						groupAvoidMaxErrorMessage(errorBox, maxSelection);
					}
					else {
						let errorMessage = document.getElementById("group_avoid_max_error");
						if (errorMessage !== null) {
							errorMessage.remove();
						}
						if (errorBox.innerHTML == "") {
							errorBox.style.display = "none";
						}
					}
					console.log(checks)
				})
			}
			groupOrAvoidCheck.addEventListener("change", function() {
				if (groupOrAvoidCheck.checked == false) {
					uncheck("id_students_selected_", nStudents);
					uncheck("id_group_or_avoid_", 1);
					checks = 0;
					let errorMessage = document.getElementById("group_avoid_max_error");
					if (errorMessage !== null) {
						errorMessage.remove();
					}
					errorBox.innerHTML = "";
					errorBox.style.display = "none";
				}
			})
		}

		function handpickTimeslotsValidation() {
			let errorBox = document.getElementById("handpick_timeslot_errors");
			errorBox.style.display = "none";
			let checks = 0;
			let maxSelection = {{max_timeslot_selection|escapejs}};
			for (let i = 0; i < nTimeslots; i++) {
				let checkboxID = "id_timeslots_to_handpick_" + i;
				let checkbox = document.getElementById(checkboxID);
				let tdID = "td_handpicked_students" + i;
				let handpickStudentsTD = document.getElementById(tdID)
				checkbox.addEventListener("change", function() {
					if (checkbox.checked == true) {
						checks += 1;
						handpickStudentsDiv.style.display = "block";
						handpickStudentsTD.style.display = "table-cell";
					} else {
						checks -= 1;
						handpickStudentsTD.style.display = "none";
						let checkboxFieldID = "id_handpicked_students"+ i + "_";
						let checkboxMax = checkboxLookup[i.toString()]['n_checkboxes'];
						resetHandpickStudentCheckboxes(i, checkboxFieldID, checkboxMax);
					}
					if (checks > maxSelection) {
						handpickTimeslotErrorMessage(errorBox, maxSelection);
					} else {
						let errorMessage = document.getElementById("handpick_timeslot_max_error");
						if (errorMessage !== null) {
							errorMessage.remove()
							errorBox.style.display = "none";
						}
					}
					if (checks == 0) {
						handpickStudentsDiv.style.display = "none";
					}
					console.log(checks)
				})
			}
			handpickCheck.addEventListener("change", function() {
				if (handpickCheck.checked == false) {
					uncheck("id_timeslots_to_handpick_", nTimeslots);
					checks = 0;
					let errorMessage = document.getElementById("handpick_timeslot_max_error");
					if (errorMessage !== null) {
						errorMessage.remove();
						errorBox.style.display = "none";
					}
					let handpickStudentErrors = document.getElementById("handpick_student_errors");
					handpickStudentErrors.innerHTML = "";
				}
			})
		}

		function handpickStudentsValidation() {
			const errorBox = document.getElementById("handpick_student_errors")
			for (let t in checkboxLookup){
				let nCheckboxes = checkboxLookup[t]["n_checkboxes"]
				let requiredStudents = checkboxLookup[t]["req_students"]
				let maxSelection = checkboxLookup[t]["n_selections"]
				let requiredChecks = requiredStudents.length
				let checks = 0 + requiredChecks
				for (let i = 0; i < nCheckboxes; i++) {
					let checkboxID = "id_handpicked_students" + t + "_" + i;
					let checkbox = document.getElementById(checkboxID);
					checkbox.addEventListener("click", function() {
						if (checkbox.checked == false) {
							checks -= 1
							if (requiredStudents.includes(checkbox.value)) {
								handpickStudentRequiredErrorMessage(errorBox, t, checkbox.value);
							}
						} else if (checkbox.checked == true) {
							checks += 1
							if (requiredStudents.includes(checkbox.value)) {
								let studentError = document.getElementById("error_" + checkbox.value)
								studentError.remove()
							}
						}
						console.log(checks)
						if (checks > maxSelection) {
							handpickStudentNErrorMessage(errorBox, t, maxSelection);
						} else {
							let maxError = document.getElementById("handpick_student_max_error_"+t);
							if (maxError !== null) {
								maxError.remove();
							}
						}
					})
				}
				let corrTimeslotCheckboxID = "id_timeslots_to_handpick_" + t
				let timeslotCheckbox = document.getElementById(corrTimeslotCheckboxID)
				timeslotCheckbox.addEventListener("change", function() {
					// resets regardless if you are checking or unchecking, since the assumption is that if you are checking, it's because it was either never selected or because it was deselected through the deselection of the initial handpicking option and should be reset anyway
					checks = 0 + requiredChecks;
					// clears errors for the particular timeslot the student selections are associated with
					let timeslotErrors = document.querySelectorAll(".t_"+t);
					for (let error of timeslotErrors) {
						error.remove()
					}
				})
			}
		}

		function uncheck(id, n) {
			for (let i = 0; i < n; i++) {
				let checkboxID = id + i;
				let checkbox = document.getElementById(checkboxID);
				checkbox.checked = false;
			}
		}

		function hideHandpickStudents() {
			handpickStudentsDiv.style.display = "none";
			for (let i = 0; i < nTimeslots; i++) {
				let tdID = "td_handpicked_students" + i;
				let handpickStudentsTD = document.getElementById(tdID);
				handpickStudentsTD.style.display = "none";
				let checkboxFieldID = "id_handpicked_students"+ i + "_";
				let checkboxMax = checkboxLookup[i.toString()]['n_checkboxes'];
				resetHandpickStudentCheckboxes(i, checkboxFieldID, checkboxMax);
			}
		}

		function resetHandpickStudentCheckboxes(i, id, n) {
			// works like uncheck() but ensures that students required to be assigned to a timeslot stay checked
			for (let ind = 0; ind < n; ind++) {
				let checkboxID = id + ind;
				let checkbox = document.getElementById(checkboxID);
				if (checkboxLookup[i]["req_students"].includes(checkbox.value)) {
					checkbox.checked = true;
				} else {
					checkbox.checked = false;
				}
			}
		}

		function refineButtonHandler() {
			refineButton.addEventListener("click", finalValidationOnSubmit);
		}

		function finalValidationOnSubmit() {
			let errorBoxes = document.querySelectorAll(".error_box");
			for (let box of errorBoxes) {
				box.innerHTML = "";
			}
			let pronounErrors, groupAvoidErrors, handpickErrors;
			if (pronounsCheck.checked == true) {
				pronounErrors = pronounValidationFinal();
				console.log("pronoun errors:", pronounValidationFinal());
			} else {
				pronounErrors = 0
			}
			if (groupOrAvoidCheck.checked == true) {
				groupAvoidErrors = groupAvoidValidationFinal();
				console.log("group avoid errors:", groupAvoidValidationFinal())
			} else {
				groupAvoidErrors = 0
			}
			if (handpickCheck.checked == true) {
				handpickErrors = handpickValidationFinal();
				console.log("handpick errors:", handpickValidationFinal())
			} else {
				handpickErrors = 0
			}
			let errorTally = pronounErrors + groupAvoidErrors + handpickErrors
			console.log("error total", errorTally)
			if (errorTally == 0) {
				processSubmission();
			}
		}

		function pronounValidationFinal() {
			let errorTally = 0
			let checks = 0;
			for (let i = 0; i < nPronounChoices; i++) {
				let checkboxID = "id_balance_by_pronouns_" + i;
				let checkbox = document.getElementById(checkboxID);
				if (checkbox.checked == true) {
					checks += 1;
				}
			}
			if (checks == nPronounChoices) {
				let errorBox = document.getElementById("pronoun_errors");
				pronounErrorMessage(errorBox);
				errorTally += 1
				console.log("all pronouns error")
			}
			return errorTally
		}

		function groupAvoidValidationFinal() {
			let errorTally = 0
			let errorBox = document.getElementById("group_avoid_errors");
			let checks = 0;
			let maxSelection = {{max_n_students_group_avoid|escapejs}}
			for (let i = 0; i < nStudents; i++) {
				let checkboxID = "id_students_selected_" + i;
				let checkbox = document.getElementById(checkboxID);
				if (checkbox.checked == true) {
					checks += 1;
				}
			}
			if (checks > maxSelection) {
				groupAvoidMaxErrorMessage(errorBox, maxSelection);
				errorTally += 1;
				console.log("group or avoid max selection error");
			}
			if (checks < 2) {
				groupAvoidMinErrorMessage(errorBox);
				errorTally += 1;
				console.log("group or avoid less than 2 error")
			}
			let radio1 = document.getElementById("id_group_or_avoid_0");
			let radio2 = document.getElementById("id_group_or_avoid_1");
			if (radio1.checked == false && radio2.checked == false) {
				groupAvoidNoRadioErrorMessage(errorBox);
				errorTally += 1;
				console.log("group or avoid no radio selection error")
			}
			return errorTally
		}

		function handpickValidationFinal() {
			let errorTally = 0
			let checks = 0;
			let maxSelection = {{max_timeslot_selection|escapejs}};
			let studentsSelected = []
			let errorBoxStudent = document.getElementById("handpick_student_errors");
			for (let i = 0; i < nTimeslots; i++) {
				let checkboxID = "id_timeslots_to_handpick_" + i;
				let checkbox = document.getElementById(checkboxID);
				if (checkbox.checked == true) {
					checks += 1;
					let studentChecks = 0
					let nStudentChecks = checkboxLookup[i]["n_checkboxes"]
					let requiredStudents = checkboxLookup[i]["req_students"]
					let maxStudentSelection = checkboxLookup[i]["n_selections"]
					for (let n = 0; n < nStudentChecks; n++) {
						let studentCheckID = "id_handpicked_students" + i + "_" + n;
						let studentCheck = document.getElementById(studentCheckID);
						if (studentCheck.checked == true) {
							studentChecks += 1;
							if (studentsSelected.includes(studentCheck.value)) {
								handpickStudentDuplicationErrorMessage(errorBoxStudent, studentCheck.value);
								errorTally += 1;
								console.log("student handpicked multiple times error")
							} else {
								studentsSelected.push(studentCheck.value);
							}
						} else if (studentCheck.checked == false) {
							if (requiredStudents.includes(studentCheck.value)) {
								handpickStudentRequiredErrorMessage(errorBoxStudent, i, studentCheck.value);
								errorTally += 1;
								console.log("required student not picked error")
							}
						}
					}
					if (studentChecks !== maxStudentSelection) {
						handpickStudentNErrorMessage(errorBoxStudent, i, maxStudentSelection);
						errorTally += 1;
						console.log("incorrect n students handpicked for timeslot error")
					}
				}
			}
			if (checks > maxSelection) {
				let errorBoxTS = document.getElementById("handpick_timeslot_errors");
				handpickTimeslotErrorMessage(errorBoxTS, maxSelection);
				errorTally += 1;
				console.log("handpick timeslot max selection error")
			}
			return errorTally
		}

		function pronounErrorMessage(errorBox) {
			errorBox.style.display = "block";
			let errorMessageExisting = document.getElementById("all_pronouns_error");
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "all_pronouns_error");
				errorMessage.innerHTML = "Selecting all pronouns will not refine your assignment options.";
				errorBox.appendChild(errorMessage);
			}
		}

		function groupAvoidMaxErrorMessage(errorBox, maxSelection) {
			errorBox.style.display = "block";
			let errorMessageExisting = document.getElementById("group_avoid_max_error");
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "group_avoid_max_error");
				errorMessage.innerHTML = "You can only select " + maxSelection  + " students or fewer to group together or keep apart.";
				errorBox.appendChild(errorMessage);
			}
		}

		function groupAvoidMinErrorMessage(errorBox) {
			errorBox.style.display = "block";
			let errorMessageExisting = document.getElementById("group_avoid_min_error");
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "group_avoid_min_error");
				errorMessage.innerHTML = "You must select at least 2 students to group together or keep apart.";
				errorBox.appendChild(errorMessage);
			}
		}

		function groupAvoidNoRadioErrorMessage(errorBox) {
			errorBox.style.display = "block";
			let errorMessageExisting = document.getElementById("group_avoid_radio_error");
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "group_avoid_radio_error");
				errorMessage.innerHTML = "You must select either <i>Group together</i> or <i>Keep apart</i>.";
				errorBox.appendChild(errorMessage);
			}
		}

		function handpickTimeslotErrorMessage(errorBox, maxSelection) {
			errorBox.style.display = "block";
			let errorMessageExisting = document.getElementById("handpick_timeslot_max_error");
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "handpick_timeslot_max_error");
				errorMessage.innerHTML += "Too many timeslots selected. Pick no more than " + maxSelection + ".";
				errorBox.appendChild(errorMessage);
			}
		}

		function handpickStudentRequiredErrorMessage(errorBox, i, student) {
			let studentErrorExisting = document.getElementById("error_" + student);
			if (studentErrorExisting == null) {
				let studentError = document.createElement("p");
				studentError.classList.add("form_error_message", "t_" + i);
				studentError.setAttribute("id", "error_" + student);
				let timeslotPK = checkboxLookup[i]["pk"];
				let timeslot = timeslotLookup[timeslotPK]["weekday"] + ", " + timeslotLookup[timeslotPK]["start_time"];
				let studentName = cnetLookup[student]["first_name"] + " " + cnetLookup[student]["last_name"];
				studentError.innerHTML += studentName + " must be included in " + timeslot + " to generate valid assignments.";
				errorBox.appendChild(studentError);
			}
		}

		function handpickStudentDuplicationErrorMessage(errorBox, student) {
			let errorMessageExisting = document.getElementById("duplication_error_" + student);
			if (errorMessageExisting == null) {
				let errorMessage = document.createElement("p");
				errorMessage.classList.add("form_error_message");
				errorMessage.setAttribute("id", "duplication_error_" + student);
				let studentName = cnetLookup[student]["first_name"] + " " + cnetLookup[student]["last_name"];
				errorMessage.innerHTML += studentName + " has been handpicked for multiple timeslots.";
				errorBox.appendChild(errorMessage);
			}
		}

		function handpickStudentNErrorMessage(errorBox, i, maxSelection) {
			let maxErrorExisting = document.getElementById("handpick_student_max_error_" + i);
			if (maxErrorExisting == null) {
				let maxError = document.createElement("p");
				maxError.classList.add("form_error_message", "t_" + i);
				maxError.setAttribute("id", "handpick_student_max_error_" + i);
				let timeslotPK = checkboxLookup[i]["pk"];
				let timeslot = timeslotLookup[timeslotPK]["weekday"] + ", " + timeslotLookup[timeslotPK]["start_time"];
				maxError.innerHTML += timeslot + " must have exactly " + maxSelection + " students assigned to it.";
				errorBox.appendChild(maxError);
			}	
		}

		function processSubmission() {
			if (pronounsCheck.checked == true) {
				processPronouns();
			}
			if (groupOrAvoidCheck.checked == true) {
				console.log("group/avoid");
			}
			if (handpickCheck.checked == true) {
				console.log("handpick")
			}
		}

		function processPronouns() {
			let pronounList = []
			for (let i = 0; i < nPronounChoices; i++) {
				let checkboxID = "id_balance_by_pronouns_" + i;
				let checkbox = document.getElementById(checkboxID);
				if (checkbox.checked == true) {
					pronounList.push(checkbox.value)
				}
			}
			console.log(pronounList);
			return pronounList
		}

		function pronounTally(students, pronounList) {
			let n = 0
			for (let student of students) {
				let pronouns = studentLookup[student]["pronouns"]
				if (pronounList.includes(pronouns)) {
					n += 1;
				}
			}
			return n
		}

		function hasSingletonAssg(combo, pronounList) {
			for (let time in combo) {
				let students = combo[time];
				if (pronounTally(students, pronounList) == 1) {
					return false
				}
			}
			return true
		}

	</script>
	</body>
</html>